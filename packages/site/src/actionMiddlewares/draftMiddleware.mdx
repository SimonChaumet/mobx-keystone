---
name: draftMiddleware
route: /actionMiddlewares/draftMiddleware
menu: Action Middlewares
---

import { FixStyle } from "../components/FixStyle.tsx"

<FixStyle />

# Action Middlewares / `draftMiddleware`

## Overview

The draft middleware allows you to make changes to a draft copy of the original subtree and apply them to the original subtree or reject them.

For example, consider this simple model:

```ts
@model("MyApp/EvenNumber")
class EvenNumber extends Model({
  value: prop<number>(),
}) {
  @computed
  get isValid(): number {
    return value % 2 === 0
  }

  @modelAction
  setValue(value: number): void {
    this.value = value
  }
}
```

We can create a draft manager for an instance of this model:

```ts
const num = new EvenNumber({ value: 0 })
const draftManager = draftMiddleware(num)
```

The draft manager can now be used to test assigning a new value by performing the `setValue` action on a draft copy of `num` and validating the result using the computed property `isValid`.

```ts
draftManager.withDraft(num, draft => {
  draft.setValue(2)
  return draft.isValid // `true` => changes will be applied to the original tree
})

// or

draftManager.withDraft(num, draft => {
  draft.setValue(3)
  return draft.isValid // `false` => changes will be rejected
})
```

The draft copy of a subtree tracks the [root store](../rootStores) state of the original subtree, i.e. when the original tree node is registered as a root store, the draft copy becomes a root store as well, and vice versa.

## `DraftManager`

The `draftManager` instance returned by calling `draftMiddleware` on a tree node offers the following methods:

- `withDraft<T extends object>(node: T, fn: (draftNode: T) => boolean | undefined | void)` - Executes `fn` with a draft of `node`. The changes made to the draft in `fn` can be accepted, i.e. applied to the original subtree, or rejected.
- `dispose()` - Disposes the draft middleware.

## Examples

### Store of polymorphic items

Consider a store of polymorphic items which can generally co-exist in the same store, but each item type implements validation rules that determine whether the item is valid in the context of the other items currently present in the store.

Let all items implement the following interface:

```ts
interface Item {
  error: string | undefined
}
```

Further, let the item store be a model which contains ...

- an array of items currently present in the store,
- a computed property which returns an array of errors accumulated from all items in the store,
- a method (action) to add a new item, and
- a method that assesses whether a new item can be added to the store without error.

```ts
const draftCtx = createContext<DraftManager>()

@model("MyApp/ItemStore")
class ItemStore extends Model({
  items: prop<Item[]>(() => []),
}) {
  @computed
  get errors(): string[] {
    return this.items.map(item => item.error).filter(error => error !== undefined) as string[]
  }

  @modelAction
  addItem(item: Item): void {
    this.items.push(item)
  }

  canAddItem(item: Item): boolean {
    let canAdd = false
    draftCtx.get(this)?.withDraft(this, draft => {
      draft.addItem(item)
      canAdd = this.errors.length === 0
    })
    return canAdd
  }
}
```

`canAddItem` requires access to the draft manager created by the draft middleware which is provided using a [context](../contexts).

```ts
const store = new ItemStore({})
const storeDraftManager = draftMiddleware(store)
draftCtx.setComputed(store, () => storeDraftManager)
```

Now, consider the following item model which, in this example, may only exist once per item store:

```ts
@model("MyApp/ItemA")
class ItemA extends Model({}) implements Item {
  @computed
  get error(): string | undefined {
    return getParent<Item[]>(this)?.some(item => item !== this && item instanceof ItemA)
      ? "only 1 instance of ItemA allowed"
      : undefined
  }
}
```

When the store does not yet contain an item of type `ItemA`, `canAddItem` returns `true` when called with an instance of `ItemA` and, thus, this item can be added to the item store without error:

```ts
const item1 = new ItemA({})
console.log(store.canAddItem(item1)) // => true
store.addItem(item1)
console.log(store.errors) // => []
```

However, adding a second item of type `ItemA` would incur an error:

```ts
const item2 = new ItemA({})
console.log(store.canAddItem(item2)) // => ["only 1 instance of ItemA allowed"]
```